\documentclass{InsightArticle}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}
\usepackage[dvips]{graphicx}
%  hyperref should be the last package to be loaded.
\usepackage[bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}

\title{$n$D morphological contour interpolation}

%
% NOTE: This is the last number of the "handle" URL that
% The Insight Journal assigns to your paper as part of the
% submission process. Please replace the number "1338" with
% the actual handle number that you get assigned.
%
\newcommand{\IJhandlerIDnumber}{1338}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
\release{0.01}

\author{D{\v z}enan Zuki{\' c}$^{1}$, Jared Vicory$^{2}$, Matthew McCormick$^{3}$ and Paul Yushkevich$^{4}$}
\authoraddress{$^{1}$dzenan.zukic@kitware.com\\
               $^{2}$jared.vicory@kitware.com\\
							 $^{3}$matt.mccormick@kitware.com\\
               $^{4}$pauly2@mail.med.upenn.edu}

\begin{document}
\IJhandlefooter{\IJhandlerIDnumber}

\ifpdf
\else
   \DeclareGraphicsExtensions{.eps,.jpg,.gif,.tiff,.bmp,.png}
   \DeclareGraphicsRule{.jpg}{eps}{.jpg.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.gif}{eps}{.gif.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.tiff}{eps}{.tiff.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.bmp}{eps}{.bmp.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.png}{eps}{.png.bb}{`convert #1 eps:-}
\fi

\maketitle

\ifhtml
\chapter*{Front Matter\label{front}}
\fi


\begin{abstract}
\noindent
This document describes a new class, \code{itk::MorphologicalContourInterpolator},
which implements a method proposed by Albu et al~\cite{Albu2008}.
This class is $n$-dimensional, and supports inputs of 3 or more dimensions.
`Slices' are $n-1$-dimensional, and can be both automatically detected and manually set.

The class is efficient in both memory used and execution time.
It requires little memory in addition to allocation of input and output images.
The implementation is multi-threaded, and processing one of the test inputs
takes around 1-2 seconds on a quad-core processor.

The class is tested to operate on both \doxygen{Image} and \code{itk::RLEImage}.
Since all the processing is done on extracted slices,
usage of \code{itk::RLEImage} for input and/or output does not affect performance.

This class is implemented to ease manual segmentation in ITK-SNAP \url{www.itksnap.org}.
The class, along with test data and automated regression tests is packaged as an ITK
remote module \url{https://github.com/KitwareMedical/ITKMorphologicalContourInterpolation}.
\end{abstract}

\IJhandlenote{\IJhandlerIDnumber}

\tableofcontents


Proliferation of automatic segmentation algorithms is on the rise,
but their performance is measured against a manually created `gold standard' segmentation.
Additionally, manual segmentation is sometimes required for other purposes.

As anyone who has ever done manual image segmentation can tell you,
it becomes monotonous very quickly.
This is especially true for high-resolution 3D images,
i.e. for 3D images with thin `slices' (because there are many of them).
The classic `cure' for this is inter-slice interpolation (Fig.~\ref{fig:InOut}).
Namely, in regions where the anatomy is slowly changing and adjacent slices are quite similar,
some slices can be skipped by a human segmenter and then interpolated by an algorithm.

\begin{figure}[htb]
\center
\includegraphics[scale=0.265]{In1.png}
\includegraphics[scale=0.265]{Out1.png}
\includegraphics[scale=0.265]{In2.png}
\includegraphics[scale=0.265]{Out2.png}
\itkcaption[InOut]{Examples of inputs (left) and outputs (right).
First row: two labels, manual segmentation on coronal slices only.
Second row: four labels, manual segmentation along all three principal axes of the body.}
\label{fig:InOut}
\end{figure}


\section{Class description}

\code{itk::MorphologicalContourInterpolation} is a class derived from
\doxygen{ImageToImageFilter}.
Input is $n$-dimensional, usually 3D.
`Slices' are cross-sections along one axis, usually 2D.
Locations of manually segmented slices can be set using
\code{SetUseCustomSlicePositionsOn} and \code{SetLabeledSliceIndices}.
The default is auto-detection of manually segmented slices using a heuristic.
%If there is a pixel whose all 4-way neighbors belong the the same label
%except along one axis, and along that axis its neighbors are 0 (background),
%then that axis should be interpolated along.

The filter can be restricted to interpolate only along one axis
and/or to interpolate just one label.
The default is to interpolate all labels along all axes.

The shapes in `source slices' need to be aligned for interpolation.
Albu's method calls for alignment with
minimum shape displacement achieving maximum shape overlap.
However that alignment requires inefficient exhaustive search,
so \code{HeuristicAlignment} is implemented and enabled by default.
\code{HeuristicAlignment} uses bread-first-search strategy
with `no translation' and `centroid alignment' as first two seeds.
`No translation' seed is required to prevent exceptional cases in which
`centroid alignment' produces no overlap for some concave shapes.
The search is terminated when further expansion of search space
(relative translations) leads to pixel overlap counts
less than 90\% of the current maximum.

The most compute intensive part of the algorithm~\cite{Albu2008}
is generation of two dilation sequences which transform the intersection
of the two shapes into each of them.
Those dilations can be done with either \doxygen{BinaryBallStructuringElement}
or \doxygen{BinaryCrossStructuringElement}.
The option \code{UseBallStructuringElement} controls which one is used.

As generation of the dilation sequences is computationally intensive,
we also experimented with usage of distance field.
A histogram of pixel counts of shapes `A' and `B' for different distances
can be used to calculate a threshold which directly produces median shape.
However, this approach loses the geodesic aspect of shape growth and
is not much faster (which was our hope) for our test examples.
We decided to retain it, and it is activated by \code{UseDistanceTransform}.

To minimize usage of memory, the output of interpolation is written
directly into the output image.
The interpolation is done on each axis successively,
in the order of increasing indices (0, 1, 2, ... or X, Y, Z, ...).
In case of conflicts between labels,
the label with bigger number has precedence (gets written into output).
This is in contrast to `not writing pixels which have already been written once'.
The chosen convention ensures that the output is not dependent on the
variability of execution introduced by multi-threading.
This elimination of variability also improves
reliability of automated regression tests.


\section{Performance measurements}

$n$-dimensional RLEImage is implemented as $n-1$-dimensional \doxygen{Image} of run-length lines.
A run-length line is implemented as \code{std::vector} of run-length segments.
A run-length segment is a pair consisting of pixel value and its repetition count.
A run-length line runs along the fastest chaning index, i.e. X-axis. C++ code:

\begin{verbatim}
typedef std::pair< CounterType, PixelType > RLSegment;
typedef std::vector< RLSegment > RLLine;
typedef typename itk::Image< RLLine, VImageDimension - 1 > BufferType;
typename BufferType::Pointer m_Buffer;
\end{verbatim}

All the standard iterators are specialized for \code{itk::RLEImage}:
const/writable $\times$ withIndex/without explicit index $\times$ plain/region/scanline.
In addition to this, \doxygen{RegionOfInterestImageFilter} is specialized for
Image$\rightarrow$RLEImage, RLEImage$\rightarrow$Image and RLEImage$\rightarrow$RLEImage cases.
If the RegionOfInterest is set to LargestPossibleRegion, the class effectively
does only conversion between standard \doxygen{Image} and \code{itk::RLEImage}.
If RegionOfInterest is smaller than LargestPossibleRegion,
it really behaves as a classic region of interest filter.
For RLEImage$\rightarrow$RLEImage case, the \doxygen{RegionOfInterestImageFilter}
can behave as a caster for template types for repetition counter and pixel values,
e.g. cast \code{itk::RLEImage<short,short>} into \code{itk::RLEImage<long,char>}.

\section{ITK-SNAP Performance measurements}

ITK-SNAP is a software application used to segment structures in 3D medical images.
The authors' vision was to create a tool that would be dedicated to a specific function,
segmentation, and would be easy to use and learn.
ITK-SNAP is free, open-source, and multi-platform.

Since version 3.4, snap uses RLEImage for storing and editing segmentation layer.
The interaction speed was not noticeable degraded,
but memory consumption has significantly reduced (Tab~\ref{tab:memoryConsumption}).

\begin{table}[h]
	\centering
		\begin{tabular}{llllll}
		\textbf{Image} & \textbf{Version} & \textbf{Image Size (MVox)} & \textbf{Number of labels} & \textbf{Commit Size (MB)} & \textbf{Difference}            \\
		None           & 3.x nightly      & 0                          & 0                         & 154                       & 100\%                          \\
		vb-seg         & 3.x nightly      & 116                        & 9                         & 731                       & 100\%                          \\
		wb-seg         & 3.x nightly      & 390                        & 58672                     & 3058                      & 100\%                          \\
		None           & dev\_3.6         & 0                          & 0                         & 165                       & {\color{red} \textbf{+7\%}}    \\
		vb-seg         & dev\_3.6         & 116                        & 9                         & 508                       & {\color{green} \textbf{-31\%}} \\
		wb-seg         & dev\_3.6         & 390                        & 58672                     & 2267                      & {\color{green} \textbf{-26\%}}
		\end{tabular}
	\caption{Memory consumption before addition of RLEImage (3.x nightly) and after (dev\_3.6).}
	\label{tab:memoryConsumption}
\end{table}

Scrolling through slices along different axes causes
extraction of slices from the 3D image, called `slicing'.
Slicing is the most frequently executed operation, and its performance is very important.
To take full advantage of \code{itk::RLEImage},
a slicing filter was specialized for it in ITK-SNAP.
Comparison of slicing speed across the principal axes for different input images
is given in Tab.~\ref{tab:slicingPerformance}.

\begin{table}[h]
	\centering
		\begin{tabular}{lrrrr}
																																& \textbf{Image}           & \textbf{brainParc}          & \textbf{vb-seg}             & \textbf{wb-seg}              \\
		\multirow{-2}{*}{}                  												& \textbf{Labels}          & \textbf{114}                & \textbf{9}                  & \textbf{58672}               \\
																																& X                        & 256                         & 640                         & 512                          \\
																																& Y                        & 256                         & 633                         & 512                          \\
		\multirow{-3}{*}{\textbf{Dimensions}}                        & Z                        & 256                         & 299                         & 1559                         \\
																																& X                        & 51.0                        & 105.9                       & 993.6                        \\
																																& Y                        & 39.2                        & 71.5                        & 912.1                        \\
		\multirow{-3}{*}{\textbf{itk::LabelMap}}                     & Z                        & 39.0                        & 94.8                        & 874.7                        \\
		{\color[HTML]{036400} }                                      & {\color[HTML]{036400} X} & {\color[HTML]{036400} 11.7} & {\color[HTML]{036400} 30.0} & {\color[HTML]{036400} 154.2} \\
		{\color[HTML]{036400} }                                      & {\color[HTML]{036400} Y} & {\color[HTML]{036400} 1.1}  & {\color[HTML]{036400} 2.9}  & {\color[HTML]{036400} 15.4}  \\
		\multirow{-3}{*}{{\color[HTML]{036400} \textbf{SNAP+RLE}}}   & {\color[HTML]{036400} Z} & {\color[HTML]{036400} 1.0}  & {\color[HTML]{036400} 5.6}  & {\color[HTML]{036400} 8.1}   \\
		{\color[HTML]{9A0000} }                                      & {\color[HTML]{9A0000} X} & {\color[HTML]{9A0000} 5.2}  & {\color[HTML]{9A0000} 22.5} & {\color[HTML]{9A0000} 73.9}  \\
		{\color[HTML]{9A0000} }                                      & {\color[HTML]{9A0000} Y} & {\color[HTML]{9A0000} 3.6}  & {\color[HTML]{9A0000} 10.4} & {\color[HTML]{9A0000} 43.4}  \\
		\multirow{-3}{*}{{\color[HTML]{9A0000} \textbf{SNAP-noRLE}}} & {\color[HTML]{9A0000} Z} & {\color[HTML]{9A0000} 3.6}  & {\color[HTML]{9A0000} 21.8} & {\color[HTML]{9A0000} 14.1}  \\
																																& X                        & 10.3                        & 26.3                        & 79.1                         \\
																																& Y                        & 0.5                         & 0.6                         & 1.4                          \\
		\multirow{-3}{*}{\textbf{pureITK}}                           & Z                        & 0.4                         & 0.7                         & 0.6                         
		\end{tabular}
	\caption{Slicing performance of \texttt{LabelMap} using \texttt{ChangeRegionLabelMapFilter},
	ITK-SNAP with \texttt{itk::RLEImage}, ITK-SNAP with \texttt{Image},
	and \texttt{Image} using \texttt{RegionOfInterestImageFilter}. All durations are in milliseconds.}
	\label{tab:slicingPerformance}
\end{table}

These results show that slicing across the run-length lines is about
twice slower than through uncompressed image.
However, slicing along run-length lines is faster than the algorithm
ITK-SNAP employed before, and not significantly slower than  `pure ITK' RoI filter.
Additionally, it is a few times faster than slicing through \doxygen{LabelMap}.

\section{Acknowledgments}

This work is supported by NIH grant R01 EB014346,
`Continued development and maintenance of the ITK-SNAP 3D image segmentation software'.

\bibliographystyle{plain}
\bibliography{InsightJournal}

\end{document}
